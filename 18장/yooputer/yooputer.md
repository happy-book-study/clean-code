# 부록A 동시성2
#### 다중스레드
단일스레드 환경에서 속도를 끌어올릴 수 있는 방법은 거의 없다
다중 스레드를 사용하면 성능이 높아질까?
그럴지도 모르지만, 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다.
가능성은 다음 두가지다.
1. I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등
2. 프로세스 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

프로그램이 주로 프로세스 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높일  수 있다.
프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다.

#### 스레드 관리
- 스레드 관리는 한 곳으로 몰아야 한다. 그래야 스레드를 제어하고 동시성 정책을 수정하기 쉽다.

#### 경로 수
- 루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로의 수는 $(NT)!/N!^T$ 이다
- synchronized 처리를 하면 가능한 경로의 수는 T개로 줄어든다.

#### 원자적 연산
- 원자적 연산이란 중단이 불가능한 연산이다.
- 자바 메모리 모델에 의하면 32비트 메모리에 값을 할당하는 연산은 중단이 불가능하다
- 원자적 연산이 아닌 경우 중간에 다른 스레드가 끼어들어 값을 바꿀 수 있다.
- ++연산은 원자적 연산이 아니다. 따라서 공유 객체/값이 있는 곳, 동시 읽기/수정 문제를 일으킬 소지가 있는 코드 곳에서 사용을 주의해야한다

#### Executor 프레임워크
- 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 스레드를 재사용하는 프레임워크
- Future, Runnable 인터페이스를 구현한 클래스, Callable 인터페이스를 구현한 클래스 지원

#### non blocking 방법
- synchronized 키워드는 언제나 lock을 건다. 락을 거는 대가는 비싸다.
- non blocking 방식은 여러 스레드가 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발한다. 
- 메서드가 공유 변수를 갱신하려 든다면 CAS 연산은 현재 변수 값이 최종으로 알려진 값인지 확인 후 갱신한다. 
	- CAS 연산은 데이터베이스 분야에서 낙관적 잠금이라는 개념과 유사하다
- 자바 5에서 AtomicBoolean, AtomicInteger, AtomicReference 등의 클래스를 통해 구현할 수 있다

#### 다중 스레드 환경에서 안전하지 않은 클래스
- 몇몇 collection 클래스
- 데이터베이스 연결
- 서블릿

#### Hashtable 동시성 처리
- synchronized 블록으로 감싸기
- 객채로 감싼 후 api를 사용하기
- ConcurrentHashMap 사용하기

#### 메서드 사이의 의존성으로 인한 문제 해결법
- 클라이언트-기반 잠금 메커니즘
	- 공유 자원을 사용하는 모든 코드에 synchronized 키워드 사용
- 서버-기반 잠금 메커니즘
	- synchronized 키워드를 감싸는 클래스를 구현하고 그 클래스를 통해 공유자원을 사용
	- 코드 중복 감소, 성능 증가, 오류 발생가능성 감소
	- 스레드 정책이 하나고 공유 범수 범위가 줄어듦
- 서버 코드를 수정하지 못하는 경우 ADAPTER 패턴을 사용
- 공유자원을 스레드에 안전한 집합 클래스 사용

#### 데드락
- 데드락의 조건
	- 상호 배제
		- 개수가 제한적인 공유 불가능한 자원
		- ex) 데이터베이스 연결, 쓰기용 파일 열기, 레코드 락, 세마포어
	- 잠금 & 대기
		- 스레드가 자원을 점유하면 나머지 자원을 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않음
	- 선점 불가
		- 다른 스레드의 자원을 빼앗지 못함
	- 순환 대기
		- 서로 점유하고 있는 자원을 필요로함
- 데드락 피하기 전략
	- 상호 배제 조건 깨기
		- 동시에 사용해도 괜찮은 자원 사용
		- 자원 수를 스레드 수 이상으로 늘리기
		- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인
	- 잠금 & 대기 조건 깨기
		- 필요한 자원들 중 하나라도 점유하지 못하면 모든 자원을 내놓고 처음부터 시작
			- 기아, 라이브락 문제 발생 가능
			- 기아 : 한 스레드가 필요한 자원을 점유하지 못함
			- 라이브락 : 여러 스레드가 한번에 락하려고 하면 계속 점유했다가 내놨다가를 반복하게 됨
			- 기아는 CPU 효율을 저하시키고, 라이브락은 쓸데 없이 CPU만 많이 사용
	- 선점 불가 조건 깨기
		- 다른 스레드로부터 자원 뺏어오기
	- 순환 대기 조건 깨기
		- 모든 스레드가 일정 순서에 동의하고 그 순서로만 자원 할당
